#ifndef lint
static char rcsid[] = "$Id: lpd.c,v 1.2 1992/12/22 19:01:25 johnr Exp $";
#endif

#include <conf.h>
#include <kernel.h>
#include <network.h>
#include <systypes.h>
#include <lpd.h>
#include <spooler.h>

/*
 *    LOCAL DEFINES
 */
#define    SZ_DBUF        1024        /* size of reads and writes from TCP device */
#define    SBSZ        80            /* storage buffer size */

/*
 *    EXTERNALLY REFERENCED FUNCTIONS
 */
extern    u_char        *index();
extern    void        spool_hostname(), spool_username(), spool_filename();

/*
 *    LOCAL FUNCTIONS - GLOBAL
 */
PROCESS        lp_dd(), lp_d();

/*
 *    LOCAL FUNCTIONS - STATIC
 */
static    int        check_slots(), send_ack(), send_pclose();
static    void    extract_data(), extract_control();

/*
 *    LOCAL VARIABLES - STATIC
 *
 *    lpd_sem    is a semaphore that is initialized in the "master" process, lp_d.
 *        It controls when lp_d is suspended due to all slots being busy.
 *
 *    lpd_slots is a data structure that holds information concerning the
 *        state of each lpd connection.
 *
 *    lpd_pname is a pointer to a pre-initialized string.  It is used to set
 *        the process-name parameter in the create system call.
 *
 *    data_buf is an array of data buffers, 1 buffer per lpd connection.
 *        This data buffer is used for reading and writing data from/to
 *        the network.
 *
 */
static    int            lpd_sem;
static    LPD_SLOTS    lpd_slots[LPD_NSLOTS];
static    u_char        *lpd_pname = "lpdx";
static    u_char        data_buf[LPD_NSLOTS][SZ_DBUF];


/*
 *    FUNCTION lp_dd - line printer daemon (direct)
 *
 *    DESCRIPTION
 *        This function is really a Xinu process, and is created and started
 *        up in the lp_d process.  It communicates directly with an lpd
 *        client and handles the server part of the connection.  The code
 *        in this process handles all of the messages as defined in RFC1179,
 *        but some features are not completely implemented.   In particular,
 *        most of the data within the control message (Section 7 of the RFC)
 *        is simply ignored.
 *
 *        The chief purpose of this process is to receive data over the
 *        network and send it to the spooler.  Processing of the data is
 *        not performed, and the "raw" bytes read in over the network are
 *        written verbatim to the spooler.
 *
 *    PARAMETERS
 *        There are no parameters in the literal sense, however this
 *        process uses receipt of a message effectively as an input parameter.
 *
 *        The message that it receives is generated by process lp_d.  It
 *        indicates the "slot number" that this particular connection should
 *        use.  This "slot number" refers to the index into the lpd_slots
 *        array which this process should use.  There is one field of the
 *        lpd_slots array which is also effectively used as an input parameter.
 *        Field lp_fd of lpd_slots holds the file descriptor this process
 *        needs to use for reading and writing from/to the network.
 *
 *    RETURN VALUES
 *        Again, there are no literal return values, however there is a
 *        "return action".  This return action is to perform a "signal"
 *        on lpd_sem.  This effectively opens up the slot and again
 *        makes this process available for another connection.
 */
PROCESS
lp_dd()
{
    u_long            slot;        /* index into lpd_slots for this connect */
    u_long            tlen;        /* temporary length counter */
    u_long            lfsize;        /* accumulated file length */
    u_char            *t0_ptr;    /* temporary pointer */
    u_char            *t1_ptr;    /* temporary pointer */
    int                fd;            /* device descriptor for read/writes */
    u_long            skey;        /* key value returned by spool_connect */
    u_long            sdd;        /* spooler device descriptor */
    int                cflag;        /* indicates if check_slots has run */
    u_char            sbuf[SBSZ];    /* storage buffer */
    struct devsw    *devptr;    /* pointer to device switch table */
    struct tcb        *ptcb;        /* pointer to tcp control block */

    register    u_char        *dptr;        /* pointer through data_buf */
    register    LPD_SLOTS    *lptr;        /* pointer to appropriate lpd_slots */
    register    u_long        len;        /* remaining len of bytes in data_buf */
    register    u_long        x;            /* just a temp */
    register    u_long        y;            /* just a temp */

    /*
     *    Only the very 1st time through do we need to skip the
     *    first few statements
     */
    goto top_recv0;

top_recv:

    /*
     *    Setting lp_status to 0 opens up the slot, and signaling
     *    lpd_sem un-suspends lp_d if it had previously been suspended.
     */
    lptr->lp_status = 0;
    signal(lpd_sem);

    /*
     *    Disconnect from the spooler if there was previously a
     *    valid connection
     */
    if (sdd)
        spool_disconnect(sdd,skey);

top_recv0:

    slot   = receive();
    lptr   = &lpd_slots[slot];
    fd     = lptr->lp_fd;
    sdd    = 0;
    cflag  = 0;

    while (1)
    {
        if ((len = read(fd, data_buf[slot], SZ_DBUF)) <= 0)
        {
            xp_tracev(80,"lp_dd: read returned ERROR, len = %d\n",len);
            close(fd);
            goto top_recv;
        }

        for (dptr = data_buf[slot]; len; )
        {
        switch (lptr->lp_command)
        {
            case 0:                        /* no command has been received yet */
            {
                switch (*dptr)
                {
                    case LPC_PRINTW:        /* 1, Print any waiting job */
                        if (send_ack(fd,0) < 0)
                            goto top_recv;

                        send_pclose(fd);
                        goto top_recv;

                    case LPC_RECVJOB:        /* 2, receive a printer job */


                        lptr->lp_command = LPC_RECVJOB;

                        /*
                         *    Send Positive acknowledgment
                         */
                        if (send_ack(fd,0) < 0)
                            goto top_recv;

                        /*
                         *    Move thru buffer until *dptr == \n, then skip
                         *    past the \n
                         */
                        for (--len; *dptr != 10; dptr++,len--)
                            ;
                        dptr++;

                        lptr->lp_state = LPS_WAITSC;
                        break;

                    case LPC_SQSS:            /* 3, Send Q state (short) */
                        lptr->lp_command = LPC_SQSS;
                        goto cheat2;

                    case LPC_SQSL:            /* 4, Send Q state (long) */

                        lptr->lp_command = LPC_SQSL;
cheat2:
                        /*
                         *    Send Positive acknowledgment
                         */
                        if (send_ack(fd,0) < 0)
                            goto top_recv;

                        /*
                         *    Call spool_lpq.  It does all the real work.
                         */
                        spool_lpq(data_buf[slot],SZ_DBUF,fd,lptr->lp_command);

                        send_pclose(fd);
                        goto top_recv;

                    case LPC_RMJOBS:        /* 5, Remove Q jobs */
                        lptr->lp_command = LPC_RMJOBS;

                        /*
                         *    Send Positive acknowledgment
                         */
                        if (send_ack(fd,0) < 0)
                            goto top_recv;

                        devptr = &devtab[fd];
                        ptcb   = (struct tcb *)devptr->dvioblk;

                        /*
                         *    Call spool_lprm.  It does all the real work.
                         */
                        spool_lprm(data_buf[slot],SZ_DBUF,fd,ptcb->tcb_rip);

                        send_pclose(fd);
                        goto top_recv;

                    default:
                        printf("lp_dd: Unexpected message type in lpd\n");
                        send_pclose(fd);
                        goto top_recv;

                }                /* end switch (*dptr) */
                break;
            }                     /* end case 0: */

            case LPC_RECVJOB:
            {
                if (lptr->lp_state & LPS_WAITSC)
                {
                    switch (*dptr)
                    {
                        case RJSC_ABORT:            /* abort job sub-command */

                            printf("lp_dd: case RJSC_ABORT\n");

                            /*
                             *    Send Positive acknowledgment
                             */
                            if (send_ack(fd,0) < 0)
                                goto top_recv;

                            /*
                             *    Move thru buffer until *dptr == \n, then skip
                             *    past the \n
                             */
                            for (--len; *dptr != 10; dptr++,len--)
                                ;
                            dptr++;
                            break;

                        case RJSC_CONTROL:            /* receive control file */
                        case RJSC_DATA:                /* receive data file */
                            /*
                             *    Check to see if all the other slots are
                             *    busy with "receive job" commands.  If all
                             *    other slots are busy with receiving data,
                             *    then this connection must be closed in order
                             *    to reserve it for a non-RECVJOB command.
                             */
                            if (!cflag & check_slots(slot) < 0)
                            {
                                /*
                                 *    NACK this message with a 2,    which will
                                 *    cause lpd to sleep for 5 minutes, then
                                 *    try again.
                                 */
                                if (send_ack(fd,2) < 0)
                                    goto top_recv;

                                send_pclose(fd);
                                goto top_recv;
                            }

                            cflag  = 1;    /* indicates check_slots has run */
                            lfsize = 0;    /* local file size inits to 0 */

                            /*
                             *    Transition states
                             */
                            if (*dptr == RJSC_CONTROL)
                                lptr->lp_state |= LPS_RECVCONT;
                            else
                                lptr->lp_state |= LPS_RECVDATA;
                            lptr->lp_state &= ~LPS_WAITSC;

                            /*
                             *    Send Positive acknowledgment
                             */
                            if (send_ack(fd,0) < 0)
                                goto top_recv;

                            /*
                             *    Grab the data out of the message.
                             *        lp_fsize - holds the file size
                             *        sbuf     - holds the file name
                             */
                            extract_data(dptr,&lptr->lp_fsize,sbuf);

                            /*
                             *    Move thru buffer until *dptr == 10, then
                             *    skip past the NL
                             */
                            for (--len; *dptr != 10; dptr++,len--)
                                ;
                            dptr++;

                            /*
                             *    Connect with the spooler. Keep trying until
                             *    a valid device descriptor is returned.
                             */
                            if (sdd == 0)
                            {
                                while (!(sdd=spool_connect(&skey,SPL_LPD)))
                                    sleep10(5);
                            }

                            /*
                             *    Set the QJOB filename and the QJOB host
                             *    name.
                             */
                            if (lptr->lp_state & LPS_RECVDATA)
                            {
                                spool_filename(sdd,skey,sbuf);
                                t0_ptr = &sbuf[6];
                                spool_hostname(sdd,skey,t0_ptr);

                                devptr = &devtab[fd];
                                ptcb   = (struct tcb *)devptr->dvioblk;

                                spool_hostip(sdd,skey,ptcb->tcb_rip);
                            }

                            break;

                        default:
                            printf("lp_dd: Unexpected sub-command in lpd\n");
                            send_pclose(fd);
                            goto top_recv;

                    }        /* end switch (*dptr) */
                    break;
                }

                if (lptr->lp_state & LPS_RECV00)
                {
                    /*
                     *    Panic system if data byte is not 0
                     */
                    if (*dptr != 0)
                    {
                        printf("lp_dd: *dptr = 0x%x\n",*dptr);
                        printf("lp_dd: LPS_RECV00 expected a 0\n");
                        send_pclose(fd);
                        goto top_recv;
                    }

                    /*
                     *    Send Positive acknowledgment
                     */
                    if (send_ack(fd,0) < 0)
                        goto top_recv;

                    /*
                     *    Turn off the RECV00 state, and skip past the 0
                     */
                    lptr->lp_state &= ~LPS_RECV00;
                    len--;  dptr++;

                    /*
                     *    Disconnect from spooler if both data file
                     *    and control file are on-board.
                     */
                    x = lptr->lp_state;
                    if ((x & LPS_DATADONE) && (x & LPS_CONTDONE))
                    {
                        spool_disconnect(sdd,skey);
                        sdd            = 0;
                        lptr->lp_state = LPS_WAITSC;
                    }
                    else
                        lptr->lp_state |= LPS_WAITSC;
                }
                else        /* RECVDATA || RECVCONT */
                {
                    /*
                     *    Calculate the number of bytes in this
                     *    data message.
                     */
                    if ((lfsize + len) > lptr->lp_fsize)
                        tlen = lptr->lp_fsize - lfsize;
                    else
                        tlen = len;

                    /*
                     *    Update counters, pointers
                     */
                    lfsize = lfsize + tlen;
                    len    = len - tlen;
                    t0_ptr = dptr;
                    dptr   = (u_char *)((u_long)dptr + tlen);

                    if (lptr->lp_state & LPS_RECVDATA)
                    {
                        /*
                         *    Send the data to the spooler
                         */
                        if (spool_write(sdd,skey,t0_ptr,tlen))
                        {
                            send_pclose(fd);
                            goto top_recv;
                        }
                        x = ~LPS_RECVDATA;
                        y = LPS_DATADONE;
                    }
                    else
                    {
                        extract_control(t0_ptr,dptr,sdd,skey);
                        x = ~LPS_RECVCONT;
                        y = LPS_CONTDONE;
                    }

                    /*
                     *    Transition states if all the data has arrived
                     */
                    if (lfsize > lptr->lp_fsize)
                    {
                        printf("lp_dd: LPS_RECVXXXX, lfsize > lp_fsize\n");
                        send_pclose(fd);
                        goto top_recv;
                    }
                    else if (lfsize == lptr->lp_fsize)
                    {
                        lptr->lp_state &= x;
                        lptr->lp_state |= (LPS_RECV00 | y);
                        lfsize = 0;
                    }
                }

                break;
            }                /* end case LPC_RECVJOB */

        }    /* end    switch (lptr->command) */
        }    /* end    for (dptr = data_buf[slot]; len; ) */
    }

    goto top_recv;
}

/*
 *    FUNCTION    lp_d - line printer daemon
 *
 *    DESCRIPTION
 *        This function is really a Xinu process, and is created and started
 *        up in main().  lp_d starts off by initializing the lpd_slots array
 *        and creating a number of lp_dd processes.   Then the TCP master
 *        device is opened and the listen-queue length is set.
 *
 *        Once all of the initialization is done, an infinite loop is entered.
 *        This loop is an endless process of:
 *                    - suspend self if no available connections
 *                    - accept a network connection
 *                    - find available slot, and send message to lp_dd
 *
 *    PARAMETERS
 *        There are no input parameters, and there are no output parameters
 *        in the literal sense.  However there is an output parameter in the
 *        "message" sense.   The available slot (an array index) is sent
 *        in a single-byte message to one of the lp_dd processes.  Also,
 *        field lp_fd in lpd_slots is used to store the file descriptor
 *        that was returned in the control system call.
 *
 *    RETURN VALUES
 *        None - This process never terminates
 *
 */
PROCESS
lp_d()
{
    int        i;
    int        fd;
    int        fd1;

    /*
     *    Initialize the per-connect lpd data structure
     */
    for (i=0; i < LPD_NSLOTS; ++i)
    {
        /*
         *    status = 0, means this slot is available
         */
        lpd_slots[i].lp_status = 0;

        /*
         *    Manipulate the process name
         */
        if (i >= 10)
            *(lpd_pname + 3) = i + 0x57;
        else
            *(lpd_pname + 3) = i + 0x30;

        /*
         *    Create the process, assign the pid, and start it up
         */
        lpd_slots[i].lp_pid = create(lp_dd, 8192, 35, lpd_pname, 0);
        resume(lpd_slots[i].lp_pid);
    }

    /*
     *    Create a semaphore.  This semaphore controls when this process
     *    needs to be suspended due to all slots being busy.
     */
    lpd_sem = screate(LPD_NSLOTS);

    /*
     *    Open up the TCP master device, and set the listen-queue length
     */
    fd = open(TCP, ANYFPORT, PRINTER_PORT);
    control(fd, TCPC_LISTENQ, LPD_NSLOTS+LPD_NSLOTS);

    while (1)
    {
        /*
         *    Wait for a slot to become available
         */
        wait(lpd_sem);

        /*
         *    Wait for a TCP connection
         */
        fd1 = control(fd, TCPC_ACCEPT);

        /*
         *    Find an available slot, initialize fields of the
         *    per-connect data structure, and send a message to the
         *    appropriate process which will handle the connection.
         */
        for (i=0; i < LPD_NSLOTS; ++i)
        {
            if (lpd_slots[i].lp_status == 0)
            {
                lpd_slots[i].lp_status  = 1;
                lpd_slots[i].lp_command = 0;
                lpd_slots[i].lp_state   = 0;
                lpd_slots[i].lp_fsize   = 0;
                lpd_slots[i].lp_fd      = fd1;
                send(lpd_slots[i].lp_pid,i);
                break;
            }
        }

    }
}

/*
 *    FUNCTION check_slots - check the slots for availability
 *
 *    DESCRIPTION
 *        This function determines whether a RECVJOB connection can
 *        be allowed.  One of the available "slots" in lpd_slots is
 *        always reserved for a non-RECVJOB message.  If there are no
 *        slots available for a RECVJOB connection then an error code
 *        is returned.
 *
 *    PARAMETERS
 *        slot -    an input parameter indicating the array index of the currently
 *                requested connection.
 *
 *    RETURN VALUES
 *        -1 -    The connection cannot be allowed
 *        0  -    OK, the connection may be allowed
 *
 */
static int
check_slots(slot)
int        slot;
{
    int        x;        /* used to hold starting index */
    int        i;        /* index through lpd_slots */

    /*
     *    If the slot is 0, then just start search at 1
     */
    x = (slot == 0) ? 1 : 0;

    /*
     *    For each entry in the slot array
     */
    for (i=x; i < LPD_NSLOTS; )
    {
        /*
         *    If lp_status == 0, then there is a slot available for a
         *        non-RECVJOB.  Remember,    lp_status is already non-zero
         *        for this connection.
         *    ELSE if the command for the particular slot is non-RECVJOB,
         *        then a slot is already reserved for non-RECVJOB, so this
         *        request will be OK
         */
        if (lpd_slots[i].lp_status == 0)
            break;
        else if (lpd_slots[i].lp_command != LPC_RECVJOB)
            break;

        /*
         *    Increment i, but skip over slot that represents this connection
         */
        if (++i == slot)
            i++;
    }

    /*
     *    If i >= LPD_NSLOTS, then an available slot was not found, and
     *        an error message is returned indicating that this connection
     *        should not be allowed.
     */
    if (i >= LPD_NSLOTS)
        return(-1);
    else
        return(0);
}

/*
 *    FUNCTION send_ack -    Send acknowledgement
 *
 *    DESCRIPTION
 *        This function sends a one-byte acknowledgement over the network
 *        to the client process.  
 *
 *    PARAMETERS
 *        fd    -    file descriptor of network device (for writing)
 *        ack    -    The value to send as the ack response
 *
 *    RETURN VALUES
 *        -1    -    the write system call has returned an error
 *        0    -    OK, the ack was successfully sent
 */
static int
send_ack(fd,ack)
int            fd;                /* file descriptor to use in write */
int            ack;            /* acknowledgment byte to send */
{
    u_char        resp_buf[2];
    int            slen;

    resp_buf[0] = ack;
    resp_buf[1] = 0;

    if ((slen = write(fd, resp_buf, 1)) < 1)
    {
        xp_tracev(80,"send_ack: write returned ERROR, slen = %d\n",slen);
        close(fd);
        return(-1);
    }
    return(0);
}

/*
 *    FUNCTION send_pclose - send premature close
 *
 *    DESCRIPTION
 *        This function is called when it is wished to close down the
 *        TCP connection.  The close is done in a non-standard way, but
 *        works much better this way.  Before closing, the tcb_state field
 *        is set to TCPS_CLOSEWAIT.  This has the effect of NOT waiting
 *        for the close to complete, and it happens immediately.
 *
 *    PARAMETER
 *        fd    -    The file descriptor of the TCP device (used for the close)
 *
 *    RETURN VALUES
 *        none
 */
static int
send_pclose(fd)
int        fd;
{
    struct devsw    *devptr;
    struct tcb        *ptcb;

    devptr          = &devtab[fd];
    ptcb            = (struct tcb *)devptr->dvioblk;
    ptcb->tcb_state = TCPS_CLOSEWAIT;
    close(fd);
}

/*
 *    FUNCTION extract_data - extract data
 *
 *    DESCRIPTION
 *        This function extracts the information out of the LPD
 *        02 (Receive control file) or 03 (Receive data file) Receive
 *        Job subcommands.  The information in these messages is formatted
 *        as follows:
 *
 *        +----+-------+----+------+----+
 *        | 02 | Count | SP | Name | LF |
 *        +----+-------+----+------+----+
 *
 *        The "Count" field is an ascii representation of the file size.
 *        The "Name" field is the name of the file to be received.
 *        See RFC1179 for further information.
 *
 *    PARAMETERS
 *        dptr    -    points to beginning of the above-described string
 *        fsize    -    pointer to storage of variable for file size
 *        sbuf    -    pointer to storage of array to hold file name
 *
 *    RETURN VALUES
 *        none    -    Function does not have a return value
 *        fsize    -    holds valid file size
 *        sbuf    -    holds valid file name
 */
static void
extract_data(dptr,fsize,sbuf)
register    u_char        *dptr;
            u_long        *fsize;
            u_char        *sbuf;
{
    register    u_char    *t0_ptr;        /* just a temp pointer */
    register    u_char    *t1_ptr;        /* just a temp pointer */

    /*
     *    Skip over the 1st byte, then find the
     *    SP between the filesize and the filename
     */
    dptr++;
    t0_ptr = index(dptr,32);

    /*
     *    Change the SP to a 0, and convert to
     *    ascii.
     */
    *t0_ptr = 0;
    *fsize  = atoi(dptr);

    /*
     *    Skip over the 0 terminating the count,
     *    and find the NL terminating the filename
     */
    t1_ptr = ++t0_ptr;
    t0_ptr = index(t1_ptr,10);

    /*
     *    Change the NL to a 0, store the
     *    filename, then put the NL back
     */
    *t0_ptr = 0;
    strcpy(sbuf,t1_ptr);
    *t0_ptr = 10;
}

/*
 *    FUNCTION extract_control - extract control information
 *
 *    DESCRIPTION
 *        This function extracts the information out of the LPD Control
 *        File.  The LPD Control file contains commands which represent
 *        functions to be performed when the data file is printed.  Most
 *        of the information in the Control file is ignored, because it
 *        is not pertinent in the Xinu embedded environment.  Currently
 *        only 3 fields are extracted, and they provide information which
 *        further describe the QJOB.  The host name, user name, and file
 *        name are the 3 fields which are extracted.  Once extracted, the
 *        appropriate spooler function is called in order to get the
 *        information into the QJOB.  See RFC1179, section 7, for
 *        further information.
 *
 *    PARAMETERS
 *        startp    -    pointer to 1st character in the control file
 *        endp    -    pointer to last character in the control file
 *        sdd        -    spool device descriptor returned by the connect call
 *        skey    -    spool device key sequencer returned by the connect call
 *
 *    RETURN VALUES
 *        none
 */
static void
extract_control(startp,endp,sdd,skey)
register    u_char        *startp;
            u_char        *endp;
            u_long        skey;
            u_long        sdd;
{
                void    (*funcp)();
    register    u_char    *tptr;
    register    u_char    *xptr;

    do
    {
        switch (*startp)
        {
            case 'H':            /* host name */
                funcp = spool_hostname;
                goto cheater0;

            case 'P':            /* user name */
                funcp = spool_username;
                goto cheater0;

            case 'N':            /* file name */
                funcp = spool_filename;
cheater0:
                /*
                 *    Increment past the 1st character and point
                 *    right at the wanted string
                 */
                startp++;

                /*
                 *    Find the NL, and change it to 0, effectively
                 *    terminating the string
                 */
                tptr  = index(startp,10);
                *tptr = 0;

                /*
                 *    The following is really only valid for the file name.
                 *    Just skip over all the /'s (slashes) in order to get to
                 *    the real file name.  This should effectively be a nop
                 *    for user name and host name
                 */
                while ((xptr = index(startp,'/')) != 0)
                    startp = ++xptr;

                /*
                 *    Call the appropriate function to store the string
                 *    in the QJOB
                 */
                (*funcp)(sdd,skey,startp);

                break;

            default:
                tptr = index(startp,10);
                break;
        }

    } while ((startp = ++tptr) < endp);
}


/*
 * $Log: lpd.c,v $
 * Revision 1.2  1992/12/22  19:01:25  johnr
 * JR:  Modified the call to spool_lprm to add an addition function parameter,
 *      that of the IP address.
 *
 * Revision 1.1  1992/11/25  22:54:29  johnr
 * JR:  1st entry for these files, in the new directory layout.
 *
 *
 */
